<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Tower Defense</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            height: 100%;
            max-height: 100vh;
        }

        .canvas-wrapper {
            height: calc(100vh - 20px);
            display: flex;
            align-items: center;
        }

        #gameCanvas {
            border: 3px solid #444;
            border-radius: 4px;
        }

        .control-panel {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            width: 280px;
            min-width: 280px;
            max-width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        .score-display {
            margin-bottom: 20px;
        }

        .score-box {
            padding: 12px;
            border-radius: 6px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            line-height: 1.25;
            transition: box-shadow 200ms ease;
            user-select: none;
        }

        .score-flash {
            box-shadow:
                0 0 10px rgba(255, 215, 0, 0.55),
                0 0 18px rgba(255, 215, 0, 0.28);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-range {
            width: 100%;
        }

        .delay-value {
            text-align: center;
            font-size: 14px;
            color: #aaa;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-size: 14px;          /* bigger overall */
            line-height: 1.2;
            height: 80px;             /* stays the same */
            overflow: hidden;         /* no clipping via scroll; we fit text instead */
            word-wrap: break-word;
        }

        #statusText {
            white-space: normal;
            overflow-wrap: anywhere;
        }

        .btn-group-vertical {
            width: 100%;
        }

        h4 {
            color: #ccc;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        #playingAs {
            color: #bdbdbd;
            font-size: 13px;
            margin-bottom: 12px;
            user-select: none;
        }

        /* Role dialog (custom modal) */
        .role-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 9999;
        }

        .role-overlay.hidden {
            display: none;
        }

        .role-modal {
            width: min(720px, 96vw);
            background: #222;
            border: 1px solid #444;
            border-radius: 10px;
            padding: 18px 18px 14px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .role-modal h5 {
            margin: 0 0 10px 0;
            color: #e6e6e6;
        }

        .role-section {
            background: #2b2b2b;
            border: 1px solid #3f3f3f;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .role-section p {
            margin: 0 0 10px 0;
            color: #e0e0e0;
            line-height: 1.35;
        }

        .role-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <!-- Role Selection Dialog -->
    <div id="roleModalOverlay" class="role-overlay hidden" aria-modal="true" role="dialog">
        <div class="role-modal">
            <h5>Choose a side</h5>

            <div class="role-section">
                <p>
                    The goal of the game for Black is to get as many pieces to reach the bottom row as possible.
                    Black cannot capture pieces.
                </p>
                <div class="role-actions">
                    <button class="btn btn-dark" id="playBlackBtn">Play as Black</button>
                </div>
            </div>

            <div class="role-section">
                <p>
                    The goal of the game for White is to prevent Black pieces from reaching the bottom row, whether through
                    capturing them as they land on a bottom row square, or through capturing them proactively beforehand on other rows.
                </p>
                <div class="role-actions">
                    <button class="btn btn-light" id="playWhiteBtn">Play as White</button>
                </div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="control-panel">
            <h4>Chess Tower Defense</h4>
            <div id="playingAs">Playing as (choose a side)</div>

            <div class="score-display">
                <div class="score-box" id="blackReachedBox">
                    <strong id="blackReachedCount">0</strong> Black Pieces Reached the Bottom Row
                </div>
            </div>

            <div class="control-group">
                <label for="delaySlider">Animation Delay</label>
                <input type="range" class="form-range" id="delaySlider"
                       min="0" max="3000" step="100" value="1000">
                <div class="delay-value"><span id="delayValue">1000</span> ms</div>
            </div>

            <div class="btn-group-vertical" role="group">
                <button class="btn btn-success" id="startBtn">Start</button>
                <button class="btn btn-warning" id="pauseBtn">Pause</button>
                <button class="btn btn-danger" id="resetBtn">Reset</button>
            </div>

            <div class="status">
                <div id="statusText">Click Start to begin</div>
            </div>
        </div>
    </div>

    <script>
        // ============== CONFIGURATION ==============
        const BOARD_WIDTH = 8 * 2;  // 16 squares wide
        const BOARD_HEIGHT = 8 * 2; // 16 squares tall (2x2 boards)

        // Colors
        const LIGHT_SQUARE = '#E8D4A8';
        const DARK_SQUARE = '#B58863';
        const WHITE_PIECE_COLOR = '#FFFFFF';
        const WHITE_PIECE_OUTLINE = '#333333';
        const BLACK_PIECE_COLOR = '#1a1a1a';
        const BLACK_PIECE_OUTLINE = '#CCCCCC';

        // Piece values (used for AI heuristics)
        const PIECE_VALUES = {
            'pawn': 1,
            'knight': 3,
            'bishop': 3,
            'rook': 5,
            'queen': 9,
            'king': 10
        };

        // ============== GAME STATE ==============
        let canvas, ctx;
        let squareSize;
        let flashTimeout = null;

        let gameState = {
            whitePieces: [],
            blackPieces: [],
            blackReached: 0,        // count of black pieces that reached bottom row
            running: false,
            paused: false,
            delay: 1000,
            currentPlan: null,
            currentCounter: null,
            playingAs: null         // 'Black' or 'White'
        };

        // ============== PIECE CLASS ==============
        class Piece {
            constructor(type, color, x, y) {
                this.type = type;
                this.color = color;
                this.x = x;
                this.y = y;
                this.alive = true;
            }

            getValue() {
                return PIECE_VALUES[this.type] || 0;
            }

            getLetter() {
                const letters = {
                    'king': 'K',
                    'queen': 'Q',
                    'rook': 'R',
                    'bishop': 'B',
                    'knight': 'N',
                    'pawn': 'P'
                };
                return letters[this.type] || '?';
            }

            clone() {
                const p = new Piece(this.type, this.color, this.x, this.y);
                p.alive = this.alive;
                return p;
            }
        }

        // ============== INITIALIZATION ==============
        function calculateSizes() {
            const availableHeight = window.innerHeight - 30;
            squareSize = Math.floor(availableHeight / BOARD_HEIGHT);
            squareSize = Math.min(squareSize, 60);

            return {
                width: BOARD_WIDTH * squareSize,
                height: BOARD_HEIGHT * squareSize
            };
        }

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Event listeners
            document.getElementById('delaySlider').addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                // If slider is at 0, use 1ms delay
                gameState.delay = value === 0 ? 1 : value;
                document.getElementById('delayValue').textContent = gameState.delay;
            });

            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            document.getElementById('playBlackBtn').addEventListener('click', () => chooseSide('Black'));
            document.getElementById('playWhiteBtn').addEventListener('click', () => chooseSide('White'));

            resetGame();
        }

        function resizeCanvas() {
            const sizes = calculateSizes();
            canvas.width = sizes.width;
            canvas.height = sizes.height;
            draw();
        }

        function spawnPieces() {
            gameState.whitePieces = [];
            gameState.blackPieces = [];

            // Standard chess piece counts
            const pieceTypes = [
                'rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook',
                'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'
            ];

            // Spawn white pieces in lower 3 rows (rows 13-15 for 16-row board)
            const whiteStartRow = BOARD_HEIGHT - 3;
            const whitePositions = getRandomPositions(16, whiteStartRow, BOARD_HEIGHT - 1);
            pieceTypes.forEach((type, i) => {
                gameState.whitePieces.push(new Piece(type, 'white', whitePositions[i].x, whitePositions[i].y));
            });

            // Spawn TWO sets of black pieces in upper 6 rows (rows 0-5)
            const blackPositions = getRandomPositions(32, 0, 5);
            // First set
            pieceTypes.forEach((type, i) => {
                gameState.blackPieces.push(new Piece(type, 'black', blackPositions[i].x, blackPositions[i].y));
            });
            // Second set
            pieceTypes.forEach((type, i) => {
                gameState.blackPieces.push(new Piece(type, 'black', blackPositions[i + 16].x, blackPositions[i + 16].y));
            });
        }

        function getRandomPositions(count, minRow, maxRow) {
            const positions = [];
            const used = new Set();

            while (positions.length < count) {
                const x = Math.floor(Math.random() * BOARD_WIDTH);
                const y = minRow + Math.floor(Math.random() * (maxRow - minRow + 1));
                const key = `${x},${y}`;

                if (!used.has(key)) {
                    used.add(key);
                    positions.push({ x, y });
                }
            }

            return positions;
        }

        // ============== DRAWING ==============
        function draw() {
            if (!ctx) return;

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw board
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const isLight = (x + y) % 2 === 0;
                    ctx.fillStyle = isLight ? LIGHT_SQUARE : DARK_SQUARE;
                    ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
                }
            }

            // Draw pieces
            gameState.whitePieces.filter(p => p.alive).forEach(p => drawPiece(p));
            gameState.blackPieces.filter(p => p.alive).forEach(p => drawPiece(p));

            // Draw plan lines
            if (gameState.currentPlan) {
                drawPlan(gameState.currentPlan, '#ff4444', '#ff0000', squareSize * 0.3);
            }
            if (gameState.currentCounter) {
                drawPlan(gameState.currentCounter, '#44ff44', '#00ff00', squareSize * 0.4);
            }
        }

        function drawPiece(piece) {
            const cx = piece.x * squareSize + squareSize / 2;
            const cy = piece.y * squareSize + squareSize / 2;

            // Draw piece background circle
            ctx.beginPath();
            ctx.arc(cx, cy, squareSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = piece.color === 'white' ? WHITE_PIECE_COLOR : BLACK_PIECE_COLOR;
            ctx.fill();
            ctx.strokeStyle = piece.color === 'white' ? WHITE_PIECE_OUTLINE : BLACK_PIECE_OUTLINE;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw piece letter with crisp rendering
            const fontSize = Math.floor(squareSize * 0.45);
            ctx.font = `bold ${fontSize}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = piece.color === 'white' ? '#333' : '#fff';

            // Disable image smoothing for crisper text
            ctx.imageSmoothingEnabled = false;

            // Round to pixel boundary for sharper rendering
            const textX = Math.round(cx);
            const textY = Math.round(cy);
            ctx.fillText(piece.getLetter(), textX, textY);
        }

        function drawPlan(plan, lineColor, circleColor, circleRadius) {
            if (!plan || !plan.path || plan.path.length < 2) return;

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            const startX = plan.path[0].x * squareSize + squareSize / 2;
            const startY = plan.path[0].y * squareSize + squareSize / 2;
            ctx.moveTo(startX, startY);

            for (let i = 1; i < plan.path.length; i++) {
                const px = plan.path[i].x * squareSize + squareSize / 2;
                const py = plan.path[i].y * squareSize + squareSize / 2;
                ctx.lineTo(px, py);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw target circle
            const target = plan.path[plan.path.length - 1];
            const tx = target.x * squareSize + squareSize / 2;
            const ty = target.y * squareSize + squareSize / 2;

            ctx.beginPath();
            ctx.arc(tx, ty, circleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = circleColor;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // ============== MOVE GENERATION ==============
        function getValidMoves(piece, allPieces, isBlack = false) {
            const moves = [];
            const occupied = new Map();

            allPieces.forEach(p => {
                if (p.alive) {
                    occupied.set(`${p.x},${p.y}`, p);
                }
            });

            switch (piece.type) {
                case 'pawn':
                    moves.push(...getPawnMoves(piece, occupied, isBlack));
                    break;
                case 'r ook':
                    moves.push(...getRookMoves(piece, occupied, isBlack));
                    break;
                case 'knight':
                    moves.push(...getKnightMoves(piece, occupied, isBlack));
                    break;
                case 'bishop':
                    moves.push(...getBishopMoves(piece, occupied, isBlack));
                    break;
                case 'queen':
                    moves.push(...getRookMoves(piece, occupied, isBlack));
                    moves.push(...getBishopMoves(piece, occupied, isBlack));
                    break;
                case 'king':
                    moves.push(...getKingMoves(piece, occupied, isBlack));
                    break;
                default:
                    // Handle rook (fix for typo above)
                    if (piece.type === 'rook') {
                        moves.push(...getRookMoves(piece, occupied, isBlack));
                    }
                    break;
            }

            return moves;
        }

        function getPawnMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const direction = piece.color === 'black' ? 1 : -1;
            const newY = piece.y + direction;

            if (newY >= 0 && newY < BOARD_HEIGHT) {
                // Forward move
                if (!occupied.has(`${piece.x},${newY}`)) {
                    moves.push({ x: piece.x, y: newY, path: [{ x: piece.x, y: piece.y }, { x: piece.x, y: newY }] });
                }

                // Diagonal captures
                if (!noCapture) {
                    for (const dx of [-1, 1]) {
                        const newX = piece.x + dx;
                        if (newX >= 0 && newX < BOARD_WIDTH) {
                            const target = occupied.get(`${newX},${newY}`);
                            if (target && target.color !== piece.color) {
                                moves.push({ x: newX, y: newY, path: [{ x: piece.x, y: piece.y }, { x: newX, y: newY }], capture: target });
                            }
                        }
                    }
                }
            }

            return moves;
        }

        function getRookMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            for (const [dx, dy] of directions) {
                const path = [{ x: piece.x, y: piece.y }];
                let x = piece.x + dx;
                let y = piece.y + dy;

                while (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    path.push({ x, y });
                    const target = occupied.get(`${x},${y}`);

                    if (target) {
                        if (!noCapture && target.color !== piece.color) {
                            moves.push({ x, y, path: [...path], capture: target });
                        }
                        break;
                    }

                    moves.push({ x, y, path: [...path] });
                    x += dx;
                    y += dy;
                }
            }

            return moves;
        }

        function getBishopMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

            for (const [dx, dy] of directions) {
                const path = [{ x: piece.x, y: piece.y }];
                let x = piece.x + dx;
                let y = piece.y + dy;

                while (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    path.push({ x, y });
                    const target = occupied.get(`${x},${y}`);

                    if (target) {
                        if (!noCapture && target.color !== piece.color) {
                            moves.push({ x, y, path: [...path], capture: target });
                        }
                        break;
                    }

                    moves.push({ x, y, path: [...path] });
                    x += dx;
                    y += dy;
                }
            }

            return moves;
        }

        function getKnightMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const jumps = [
                [2, 1], [2, -1], [-2, 1], [-2, -1],
                [1, 2], [1, -2], [-1, 2], [-1, -2]
            ];

            for (const [dx, dy] of jumps) {
                const x = piece.x + dx;
                const y = piece.y + dy;

                if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    const target = occupied.get(`${x},${y}`);

                    if (noCapture) {
                        if (!target) {
                            const path = [{ x: piece.x, y: piece.y }];
                            if (Math.abs(dx) === 2) {
                                path.push({ x: piece.x + dx, y: piece.y });
                                path.push({ x, y });
                            } else {
                                path.push({ x: piece.x, y: piece.y + dy });
                                path.push({ x, y });
                            }
                            moves.push({ x, y, path });
                        }
                    } else {
                        if (!target || target.color !== piece.color) {
                            const path = [{ x: piece.x, y: piece.y }];
                            if (Math.abs(dx) === 2) {
                                path.push({ x: piece.x + dx, y: piece.y });
                                path.push({ x, y });
                            } else {
                                path.push({ x: piece.x, y: piece.y + dy });
                                path.push({ x, y });
                            }

                            const move = { x, y, path };
                            if (target && target.color !== piece.color) {
                                move.capture = target;
                            }
                            moves.push(move);
                        }
                    }
                }
            }

            return moves;
        }

        function getKingMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            for (const [dx, dy] of directions) {
                const x = piece.x + dx;
                const y = piece.y + dy;

                if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    const target = occupied.get(`${x},${y}`);

                    if (noCapture) {
                        if (!target) {
                            moves.push({ x, y, path: [{ x: piece.x, y: piece.y }, { x, y }] });
                        }
                    } else {
                        if (!target || target.color !== piece.color) {
                            const move = { x, y, path: [{ x: piece.x, y: piece.y }, { x, y }] };
                            if (target && target.color !== piece.color) {
                                move.capture = target;
                            }
                            moves.push(move);
                        }
                    }
                }
            }

            return moves;
        }

        // ============== AI ==============
        function blackAI() {
            const allPieces = [...gameState.whitePieces, ...gameState.blackPieces];
            const alivePieces = gameState.blackPieces.filter(p => p.alive);

            if (alivePieces.length === 0) return null;

            let bestMove = null;
            let bestScore = -Infinity;

            for (const piece of alivePieces) {
                // Black cannot capture, so pass true for noCapture
                const moves = getValidMoves(piece, allPieces, true);

                for (const move of moves) {
                    // Score based on progress toward bottom
                    let score = move.y;

                    // Bonus for reaching the back rank
                    if (move.y === BOARD_HEIGHT - 1) {
                        score += 100 + piece.getValue() * 10;
                    }

                    // Prefer valuable pieces making progress
                    score += piece.getValue() * 0.5;

                    // Add some randomness to make it less predictable
                    score += Math.random() * 0.5;

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { piece, move };
                    }
                }
            }

            return bestMove;
        }

        // White decision hierarchy:
        // 1) If possible, intercept black at its destination (capture at target square).
        // 2) Else, proactively capture some other black piece (avoid occupying black's destination square).
        // 3) Else, mobilize a piece toward the center four squares (avoid occupying black's destination square).
        function whiteAI(blackPlan) {
            if (!blackPlan) return null;

            const allPieces = [...gameState.whitePieces, ...gameState.blackPieces];
            const alivePieces = gameState.whitePieces.filter(p => p.alive);
            if (alivePieces.length === 0) return null;

            const targetX = blackPlan.move.x;
            const targetY = blackPlan.move.y;

            // ---- 1) Intercept attempt ----
            let bestIntercept = null;
            let bestInterceptScore = -Infinity;

            for (const piece of alivePieces) {
                // Pawns: only allow interception diagonally forward (do NOT allow straight-forward "capture")
                if (piece.type === 'pawn') {
                    const direction = -1; // white = -1
                    const dx = targetX - piece.x;
                    const dy = targetY - piece.y;

                    if (Math.abs(dx) === 1 && dy === direction) {
                        const score = 1000 + blackPlan.piece.getValue() * 100 - piece.getValue();
                        if (score > bestInterceptScore) {
                            bestInterceptScore = score;
                            bestIntercept = {
                                kind: 'intercept',
                                piece,
                                move: {
                                    x: targetX,
                                    y: targetY,
                                    path: [{ x: piece.x, y: piece.y }, { x: targetX, y: targetY }]
                                }
                            };
                        }
                    }
                    continue;
                }

                const moves = getValidMoves(piece, allPieces, false);
                for (const move of moves) {
                    if (move.x === targetX && move.y === targetY) {
                        let score = 1000 + blackPlan.piece.getValue() * 100;
                        score -= piece.getValue(); // prefer lower-value interceptors
                        if (score > bestInterceptScore) {
                            bestInterceptScore = score;
                            bestIntercept = { kind: 'intercept', piece, move };
                        }
                    }
                }
            }

            if (bestIntercept) return bestIntercept;

            // ---- 2) Proactive capture elsewhere ----
            let bestCapture = null;
            let bestCaptureScore = -Infinity;

            for (const piece of alivePieces) {
                const moves = getValidMoves(piece, allPieces, false);

                for (const move of moves) {
                    if (!move.capture) continue;

                    // Avoid stepping onto black's planned destination square (would invalidate black move).
                    if (move.x === targetX && move.y === targetY) continue;

                    const captured = move.capture;
                    if (!captured.alive || captured.color !== 'black') continue;

                    let score = captured.getValue() * 120 + captured.y * 1.5 - piece.getValue() * 6;
                    if (captured === blackPlan.piece) score += 40;
                    score += Math.random() * 0.25;

                    if (score > bestCaptureScore) {
                        bestCaptureScore = score;
                        bestCapture = { kind: 'capture', piece, move };
                    }
                }
            }

            if (bestCapture) return bestCapture;

            // ---- 3) Mobilize toward center four squares ----
            const centers = [
                { x: 7, y: 7 }, { x: 8, y: 7 },
                { x: 7, y: 8 }, { x: 8, y: 8 }
            ];

            const distToCenter = (x, y) => {
                let best = Infinity;
                for (const c of centers) {
                    const d = Math.abs(x - c.x) + Math.abs(y - c.y);
                    if (d < best) best = d;
                }
                return best;
            };

            let bestMobilize = null;
            let bestMobilizeScore = -Infinity;

            for (const piece of alivePieces) {
                const moves = getValidMoves(piece, allPieces, false);
                const curDist = distToCenter(piece.x, piece.y);

                for (const move of moves) {
                    if (move.capture) continue;

                    // Avoid stepping onto black's planned destination square (would invalidate black move).
                    if (move.x === targetX && move.y === targetY) continue;

                    const newDist = distToCenter(move.x, move.y);
                    const improvement = curDist - newDist;

                    let score = improvement * 20 - newDist * 0.5;
                    if (piece.type !== 'pawn') score += 1.0;
                    score += Math.random() * 0.2;

                    if (score > bestMobilizeScore) {
                        bestMobilizeScore = score;
                        bestMobilize = { kind: 'mobilize', piece, move };
                    }
                }
            }

            if (bestMobilize) return bestMobilize;

            return null;
        }

        // ============== GAME LOOP ==============
        async function gameLoop() {
            while (gameState.running) {
                if (gameState.paused) {
                    await sleep(100);
                    continue;
                }

                // Check if game should end
                const blackAlive = gameState.blackPieces.filter(p => p.alive).length;
                if (blackAlive === 0) {
                    setStatus('Game Complete');
                    gameState.running = false;
                    break;
                }

                // Black plans a move
                const blackPlan = blackAI();
                if (!blackPlan) {
                    setStatus('Game Complete');
                    gameState.running = false;
                    break;
                }

                gameState.currentPlan = blackPlan.move;
                gameState.currentCounter = null;
                draw();
                setStatus(`Black ${blackPlan.piece.type} plans: (${blackPlan.piece.x},${blackPlan.piece.y}) â†’ (${blackPlan.move.x},${blackPlan.move.y})`);
                await sleep(gameState.delay);

                if (!gameState.running) break;

                // White responds (intercept, capture elsewhere, or mobilize)
                const whitePlan = whiteAI(blackPlan);
                if (whitePlan) {
                    gameState.currentCounter = whitePlan.move;
                    draw();

                    if (whitePlan.kind === 'intercept') {
                        setStatus(`White ${whitePlan.piece.type} captures at (${whitePlan.move.x},${whitePlan.move.y})`);
                    } else if (whitePlan.kind === 'capture') {
                        setStatus(`White ${whitePlan.piece.type} captures black ${whitePlan.move.capture.type} at (${whitePlan.move.x},${whitePlan.move.y})`);
                    } else if (whitePlan.kind === 'mobilize') {
                        setStatus(`White mobilizes piece toward board center`);
                    }

                    await sleep(gameState.delay);
                }

                if (!gameState.running) break;

                // Resolve moves
                let blackCaptured = false;

                if (whitePlan) {
                    if (whitePlan.kind === 'intercept') {
                        // White captures the planned black mover by meeting it at the destination square
                        blackPlan.piece.alive = false;
                        blackCaptured = true;

                        // Move white piece to the capture point
                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    } else if (whitePlan.kind === 'capture') {
                        // White captures a black piece on its current square
                        if (whitePlan.move.capture && whitePlan.move.capture.alive) {
                            whitePlan.move.capture.alive = false;
                            if (whitePlan.move.capture === blackPlan.piece) {
                                blackCaptured = true;
                            }
                        }

                        // Move white piece to the capture square
                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    } else if (whitePlan.kind === 'mobilize') {
                        // White simply moves toward center
                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    }
                }

                // Execute black's move if not captured
                if (!blackCaptured) {
                    blackPlan.piece.x = blackPlan.move.x;
                    blackPlan.piece.y = blackPlan.move.y;

                    // Check if black reached back rank
                    if (blackPlan.piece.y === BOARD_HEIGHT - 1) {
                        gameState.blackReached += 1;
                        blackPlan.piece.alive = false;
                        flashBlackReachedBox();
                        setStatus(`Black ${blackPlan.piece.type} reached bottom row`);
                    }
                }

                gameState.currentPlan = null;
                gameState.currentCounter = null;
                draw();
                updateUI();

                await sleep(Math.max(1, gameState.delay / 2));
            }

            gameState.currentPlan = null;
            gameState.currentCounter = null;
            draw();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, Math.max(1, ms)));
        }

        // ============== UI ==============
        function updateUI() {
            const el = document.getElementById('blackReachedCount');
            if (el) el.textContent = gameState.blackReached;
        }

        function fitStatusText() {
            const box = document.querySelector('.status');
            const el = document.getElementById('statusText');
            if (!box || !el) return;

            // Reset to base (bigger overall)
            let size = 14;
            const minSize = 10;

            el.style.fontSize = size + 'px';

            // Shrink until it fits (no clipping)
            // Guard against pathological loops
            let guard = 0;
            while (el.scrollHeight > box.clientHeight && size > minSize && guard < 60) {
                size -= 0.5;
                el.style.fontSize = size + 'px';
                guard++;
            }
        }

        function setStatus(text) {
            const el = document.getElementById('statusText');
            if (!el) return;
            el.textContent = text;
            fitStatusText();
        }

        function flashBlackReachedBox() {
            const box = document.getElementById('blackReachedBox');
            if (!box) return;

            box.classList.add('score-flash');

            if (flashTimeout) clearTimeout(flashTimeout);
            flashTimeout = setTimeout(() => {
                box.classList.remove('score-flash');
                flashTimeout = null;
            }, 260);
        }

        function startGame() {
            if (!gameState.running) {
                gameState.running = true;
                gameState.paused = false;
                setStatus('Simulation running...');
                gameLoop();
            }
        }

        function togglePause() {
            gameState.paused = !gameState.paused;
            setStatus(gameState.paused ? 'Paused' : 'Resumed');
        }

        function showRoleDialog() {
            const overlay = document.getElementById('roleModalOverlay');
            if (overlay) overlay.classList.remove('hidden');
        }

        function hideRoleDialog() {
            const overlay = document.getElementById('roleModalOverlay');
            if (overlay) overlay.classList.add('hidden');
        }

        function chooseSide(color) {
            gameState.playingAs = color;
            const el = document.getElementById('playingAs');
            if (el) el.textContent = `Playing as ${color}`;
            hideRoleDialog();
        }

        function resetGame() {
            gameState.running = false;
            gameState.paused = false;
            gameState.blackReached = 0;
            gameState.currentPlan = null;
            gameState.currentCounter = null;

            spawnPieces();
            updateUI();
            draw();
            setStatus('Click Start to begin');

            showRoleDialog();
            const playingEl = document.getElementById('playingAs');
            if (playingEl) playingEl.textContent = gameState.playingAs ? `Playing as ${gameState.playingAs}` : 'Playing as (choose a side)';
        }

        // Start
        window.onload = init;
    </script>
</body>
</html>