<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Back Rank Breakthrough</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            height: 100%;
            max-height: 100vh;
        }

        .canvas-wrapper {
            height: calc(100vh - 20px);
            display: flex;
            align-items: center;
        }

        #gameCanvas {
            border: 3px solid #444;
            border-radius: 4px;
        }

        .control-panel {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            width: 280px;
            min-width: 280px;
            max-width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        .score-display {
            margin-bottom: 20px;
        }

        .score-box {
            padding: 12px;
            border-radius: 6px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            line-height: 1.25;
            transition: box-shadow 200ms ease;
            user-select: none;
        }

        .score-flash {
            box-shadow:
                0 0 10px rgba(255, 215, 0, 0.55),
                0 0 18px rgba(255, 215, 0, 0.28);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-range {
            width: 100%;
        }

        .delay-value {
            text-align: center;
            font-size: 14px;
            color: #aaa;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.2;
            height: 80px;
            overflow: hidden;
            word-wrap: break-word;
        }

        #statusText {
            white-space: normal;
            overflow-wrap: anywhere;
        }

        .btn-group-vertical {
            width: 100%;
        }

        h4 {
            color: #ccc;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        #playingAs {
            color: #bdbdbd;
            font-size: 13px;
            margin-bottom: 12px;
            user-select: none;
        }

        .btn-state-on {
            outline: 2px solid rgba(255,255,255,0.35);
            box-shadow: 0 0 10px rgba(255,255,255,0.18);
        }

        .role-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 9999;
        }

        .role-overlay.hidden {
            display: none;
        }

        .role-modal {
            width: min(720px, 96vw);
            background: #222;
            border: 1px solid #444;
            border-radius: 10px;
            padding: 18px 18px 14px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .role-modal h5 {
            margin: 0 0 10px 0;
            color: #e6e6e6;
        }

        .role-section {
            background: #2b2b2b;
            border: 1px solid #3f3f3f;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .role-section p {
            margin: 0 0 10px 0;
            color: #e0e0e0;
            line-height: 1.35;
        }

        .role-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Piece placement UI */
        .piece-counts {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-size: 13px;
        }

        .piece-counts-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #aaa;
        }

        .piece-counts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .piece-count-item {
            background: #444;
            padding: 4px 8px;
            border-radius: 3px;
            text-align: center;
            transition: box-shadow 200ms ease;
        }

        .piece-count-item.empty {
            opacity: 0.5;
        }

        .piece-count-item.count-flash {
            box-shadow:
                0 0 8px rgba(255, 215, 0, 0.6),
                0 0 14px rgba(255, 215, 0, 0.3);
        }

        .placement-hint {
            margin-top: 8px;
            font-size: 11px;
            color: #888;
            text-align: center;
        }

        .piece-counts.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Role Selection Dialog -->
    <div id="roleModalOverlay" class="role-overlay hidden" aria-modal="true" role="dialog">
        <div class="role-modal">
            <h5>Choose a side</h5>

            <div class="role-section">
                <p>
                    The goal of the game for Black is to get as many pieces to reach the bottom row as possible.
                    Black cannot capture pieces.
                </p>
                <div class="role-actions">
                    <button class="btn btn-dark" id="playBlackBtn">Play as Black</button>
                </div>
            </div>

            <div class="role-section">
                <p>
                    The goal of the game for White is to prevent Black pieces from reaching the bottom row, whether through
                    capturing them as they land on a bottom row square, or through capturing them proactively beforehand on other rows.
                </p>
                <div class="role-actions">
                    <button class="btn btn-light" id="playWhiteBtn">Play as White</button>
                </div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="control-panel">
            <h4>Back Rank Breakthrough</h4>
            <div id="playingAs">Playing as (choose a side)</div>

            <div class="score-display">
                <div class="score-box" id="blackReachedBox">
                    <strong id="blackReachedCount">0</strong> <span id="blackReachedText">Black Pieces Reached the Bottom Row</span>
                </div>
            </div>

            <div class="control-group">
                <label for="delaySlider">Game Speed</label>
                <input type="range" class="form-range" id="delaySlider"
                       min="0" max="3000" step="100" value="1000">
                <div class="delay-value"><span id="delayValue">1000</span> ms</div>
            </div>

            <div class="btn-group-vertical" role="group">
                <button class="btn btn-success" id="startBtn">Start</button>
                <button class="btn btn-warning" id="pauseBtn" disabled>Pause</button>
                <button class="btn btn-danger" id="resetBtn">Reset</button>
            </div>

            <div class="status">
                <div id="statusText">Choose a side to begin</div>
            </div>

            <!-- Piece counts display -->
            <div class="piece-counts hidden" id="pieceCountsPanel">
                <div class="piece-counts-title">Pieces to Place</div>
                <div class="piece-counts-grid">
                    <div class="piece-count-item" id="countK">K: <span>0</span></div>
                    <div class="piece-count-item" id="countQ">Q: <span>0</span></div>
                    <div class="piece-count-item" id="countR">R: <span>0</span></div>
                    <div class="piece-count-item" id="countB">B: <span>0</span></div>
                    <div class="piece-count-item" id="countN">N: <span>0</span></div>
                    <div class="piece-count-item" id="countP">P: <span>0</span></div>
                </div>
                <div class="placement-hint">
                    WASD to move cursor<br>
                    P/N/B/R/Q/K to place pieces<br>
                    X to remove a piece
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============== CONFIGURATION ==============
        const BOARD_WIDTH = 8 * 2;  // 16 squares wide
        const BOARD_HEIGHT = 8 * 2; // 16 squares tall (2x2 boards)

        // Colors
        const LIGHT_SQUARE = '#E8D4A8';
        const DARK_SQUARE = '#B58863';
        const WHITE_PIECE_COLOR = '#FFFFFF';
        const WHITE_PIECE_OUTLINE = '#333333';
        const BLACK_PIECE_COLOR = '#1a1a1a';
        const BLACK_PIECE_OUTLINE = '#CCCCCC';

        // Fog of war colors
        const FOG_LIGHT = '#a0a0a0';
        const FOG_DARK = '#707070';

        // Placement zone outline color
        const PLACEMENT_ZONE_COLOR = '#4488ff';

        // Piece values (used for AI heuristics)
        const PIECE_VALUES = {
            'pawn': 1,
            'knight': 3,
            'bishop': 3,
            'rook': 5,
            'queen': 9,
            'king': 10
        };

        // ============== GAME STATE ==============
        let canvas, ctx;
        let squareSize;
        let flashTimeout = null;
        let pieceCountFlashTimeouts = {};

        let gameState = {
            whitePieces: [],
            blackPieces: [],
            blackReached: 0,
            running: false,
            paused: false,
            gameComplete: false,
            delay: 1000,
            currentPlan: null,
            currentCounter: null,
            playingAs: null,
            blackMoveHistory: [],
            // Placement phase state
            placementPhase: false,
            cursorX: 7,
            cursorY: 7,
            piecesToPlace: {
                king: 0,
                queen: 0,
                rook: 0,
                bishop: 0,
                knight: 0,
                pawn: 0
            },
            // Track if side has been chosen (to know when to show empty board vs placed pieces)
            sideChosen: false
        };

        // Key to piece type mapping
        const KEY_TO_PIECE = {
            'p': 'pawn',
            'n': 'knight',
            'b': 'bishop',
            'r': 'rook',
            'q': 'queen',
            'k': 'king'
        };

        // Piece type to count element ID mapping
        const PIECE_TO_COUNT_ID = {
            'pawn': 'countP',
            'knight': 'countN',
            'bishop': 'countB',
            'rook': 'countR',
            'queen': 'countQ',
            'king': 'countK'
        };

        // ============== PIECE CLASS ==============
        class Piece {
            constructor(type, color, x, y) {
                this.type = type;
                this.color = color;
                this.x = x;
                this.y = y;
                this.alive = true;
            }

            getValue() {
                return PIECE_VALUES[this.type] || 0;
            }

            getLetter() {
                const letters = {
                    'king': 'K',
                    'queen': 'Q',
                    'rook': 'R',
                    'bishop': 'B',
                    'knight': 'N',
                    'pawn': 'P'
                };
                return letters[this.type] || '?';
            }

            clone() {
                const p = new Piece(this.type, this.color, this.x, this.y);
                p.alive = this.alive;
                return p;
            }
        }

        // ============== INITIALIZATION ==============
        function calculateSizes() {
            const availableHeight = window.innerHeight - 30;
            squareSize = Math.floor(availableHeight / BOARD_HEIGHT);
            squareSize = Math.min(squareSize, 60);

            return {
                width: BOARD_WIDTH * squareSize,
                height: BOARD_HEIGHT * squareSize
            };
        }

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Event listeners
            document.getElementById('delaySlider').addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                gameState.delay = value === 0 ? 1 : value;
                document.getElementById('delayValue').textContent = gameState.delay;
            });

            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            document.getElementById('playBlackBtn').addEventListener('click', () => chooseSide('Black'));
            document.getElementById('playWhiteBtn').addEventListener('click', () => chooseSide('White'));

            // Keyboard listener for placement
            document.addEventListener('keydown', handleKeyDown);

            resetGame();
        }

        function resizeCanvas() {
            const sizes = calculateSizes();
            canvas.width = sizes.width;
            canvas.height = sizes.height;
            draw();
        }

        function handleKeyDown(e) {
            if (!gameState.placementPhase) return;

            const key = e.key.toLowerCase();

            // Movement with WASD
            if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                e.preventDefault();
                moveCursor(key);
                draw();
                return;
            }

            // Piece placement
            if (KEY_TO_PIECE[key]) {
                e.preventDefault();
                placePiece(KEY_TO_PIECE[key]);
                return;
            }

            // Piece deletion
            if (key === 'x') {
                e.preventDefault();
                deletePiece();
                return;
            }
        }

        function moveCursor(direction) {
            const bounds = getPlayerBounds();

            switch (direction) {
                case 'w':
                    if (gameState.cursorY > bounds.minY) {
                        gameState.cursorY--;
                    }
                    break;
                case 's':
                    if (gameState.cursorY < bounds.maxY) {
                        gameState.cursorY++;
                    }
                    break;
                case 'a':
                    if (gameState.cursorX > 0) {
                        gameState.cursorX--;
                    }
                    break;
                case 'd':
                    if (gameState.cursorX < BOARD_WIDTH - 1) {
                        gameState.cursorX++;
                    }
                    break;
            }
        }

        function getPlayerBounds() {
            if (gameState.playingAs === 'Black') {
                return { minY: 0, maxY: 5 };
            } else {
                return { minY: BOARD_HEIGHT - 3, maxY: BOARD_HEIGHT - 1 };
            }
        }

        function flashPieceCount(pieceType) {
            const elementId = PIECE_TO_COUNT_ID[pieceType];
            if (!elementId) return;

            const element = document.getElementById(elementId);
            if (!element) return;

            element.classList.add('count-flash');

            // Clear existing timeout for this piece type
            if (pieceCountFlashTimeouts[pieceType]) {
                clearTimeout(pieceCountFlashTimeouts[pieceType]);
            }

            pieceCountFlashTimeouts[pieceType] = setTimeout(() => {
                element.classList.remove('count-flash');
                delete pieceCountFlashTimeouts[pieceType];
            }, 260);
        }

        function placePiece(pieceType) {
            // Check if we have pieces of this type to place
            if (gameState.piecesToPlace[pieceType] <= 0) {
                setStatus(`No more ${pieceType}s to place!`);
                return;
            }

            // Check if square is already occupied by player's pieces
            const playerPieces = gameState.playingAs === 'White' ? gameState.whitePieces : gameState.blackPieces;
            const occupied = playerPieces.some(p => p.alive && p.x === gameState.cursorX && p.y === gameState.cursorY);

            if (occupied) {
                setStatus('Square already occupied!');
                return;
            }

            // Place the piece
            const color = gameState.playingAs.toLowerCase();
            const newPiece = new Piece(pieceType, color, gameState.cursorX, gameState.cursorY);

            if (color === 'white') {
                gameState.whitePieces.push(newPiece);
            } else {
                gameState.blackPieces.push(newPiece);
            }

            gameState.piecesToPlace[pieceType]--;

            updatePieceCountsUI();
            flashPieceCount(pieceType);
            draw();

            // Check if all pieces placed
            const totalRemaining = Object.values(gameState.piecesToPlace).reduce((a, b) => a + b, 0);
            if (totalRemaining === 0) {
                document.getElementById('startBtn').disabled = false;
                setStatus('All pieces placed! Click Start to begin.');
            } else {
                setStatus(`Placed ${pieceType}. ${totalRemaining} pieces remaining.`);
            }
        }

        function deletePiece() {
            // Find piece at cursor position belonging to player
            const playerPieces = gameState.playingAs === 'White' ? gameState.whitePieces : gameState.blackPieces;
            const pieceIndex = playerPieces.findIndex(p => p.alive && p.x === gameState.cursorX && p.y === gameState.cursorY);

            if (pieceIndex === -1) {
                setStatus('No piece to remove here.');
                return;
            }

            const piece = playerPieces[pieceIndex];
            const pieceType = piece.type;

            // Remove the piece
            playerPieces.splice(pieceIndex, 1);

            // Add back to pieces to place
            gameState.piecesToPlace[pieceType]++;

            // Disable start button if we now have pieces to place
            const totalRemaining = Object.values(gameState.piecesToPlace).reduce((a, b) => a + b, 0);
            if (totalRemaining > 0) {
                document.getElementById('startBtn').disabled = true;
            }

            updatePieceCountsUI();
            flashPieceCount(pieceType);
            draw();
            setStatus(`Removed ${pieceType}. ${totalRemaining} pieces remaining.`);
        }

        function initializePiecesToPlace() {
            if (gameState.playingAs === 'White') {
                // White gets one standard chess set
                gameState.piecesToPlace = {
                    king: 1,
                    queen: 1,
                    rook: 2,
                    bishop: 2,
                    knight: 2,
                    pawn: 8
                };
            } else {
                // Black gets two standard chess sets
                gameState.piecesToPlace = {
                    king: 2,
                    queen: 2,
                    rook: 4,
                    bishop: 4,
                    knight: 4,
                    pawn: 16
                };
            }
        }

        function updatePieceCountsUI() {
            document.querySelector('#countK span').textContent = gameState.piecesToPlace.king;
            document.querySelector('#countQ span').textContent = gameState.piecesToPlace.queen;
            document.querySelector('#countR span').textContent = gameState.piecesToPlace.rook;
            document.querySelector('#countB span').textContent = gameState.piecesToPlace.bishop;
            document.querySelector('#countN span').textContent = gameState.piecesToPlace.knight;
            document.querySelector('#countP span').textContent = gameState.piecesToPlace.pawn;

            // Update styling for empty counts
            document.getElementById('countK').classList.toggle('empty', gameState.piecesToPlace.king === 0);
            document.getElementById('countQ').classList.toggle('empty', gameState.piecesToPlace.queen === 0);
            document.getElementById('countR').classList.toggle('empty', gameState.piecesToPlace.rook === 0);
            document.getElementById('countB').classList.toggle('empty', gameState.piecesToPlace.bishop === 0);
            document.getElementById('countN').classList.toggle('empty', gameState.piecesToPlace.knight === 0);
            document.getElementById('countP').classList.toggle('empty', gameState.piecesToPlace.pawn === 0);
        }

        function spawnOpponentPieces() {
            // Only spawn pieces for the side the player is NOT playing
            const pieceTypes = [
                'rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook',
                'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'
            ];

            if (gameState.playingAs === 'Black') {
                // Spawn white pieces randomly
                gameState.whitePieces = [];
                const whiteStartRow = BOARD_HEIGHT - 3;
                const whitePositions = getRandomPositions(16, whiteStartRow, BOARD_HEIGHT - 1);
                pieceTypes.forEach((type, i) => {
                    gameState.whitePieces.push(new Piece(type, 'white', whitePositions[i].x, whitePositions[i].y));
                });
            } else {
                // Spawn black pieces randomly (two sets)
                gameState.blackPieces = [];
                const blackPositions = getRandomPositions(32, 0, 5);
                pieceTypes.forEach((type, i) => {
                    gameState.blackPieces.push(new Piece(type, 'black', blackPositions[i].x, blackPositions[i].y));
                });
                pieceTypes.forEach((type, i) => {
                    gameState.blackPieces.push(new Piece(type, 'black', blackPositions[i + 16].x, blackPositions[i + 16].y));
                });
            }
        }

        function getRandomPositions(count, minRow, maxRow) {
            const positions = [];
            const used = new Set();

            while (positions.length < count) {
                const x = Math.floor(Math.random() * BOARD_WIDTH);
                const y = minRow + Math.floor(Math.random() * (maxRow - minRow + 1));
                const key = `${x},${y}`;

                if (!used.has(key)) {
                    used.add(key);
                    positions.push({ x, y });
                }
            }

            return positions;
        }

        // ============== DRAWING ==============
        function draw() {
            if (!ctx) return;

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw board
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const isLight = (x + y) % 2 === 0;

                    // Check if this square should be fog
                    let isFog = false;
                    if (gameState.placementPhase && gameState.playingAs) {
                        if (gameState.playingAs === 'White') {
                            // Fog on top 6 rows (black's area)
                            isFog = y <= 5;
                        } else {
                            // Fog on bottom 3 rows (white's area)
                            isFog = y >= BOARD_HEIGHT - 3;
                        }
                    }

                    if (isFog) {
                        ctx.fillStyle = isLight ? FOG_LIGHT : FOG_DARK;
                    } else {
                        ctx.fillStyle = isLight ? LIGHT_SQUARE : DARK_SQUARE;
                    }
                    ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
                }
            }

            // Draw placement zone outline during placement phase
            if (gameState.placementPhase) {
                drawPlacementZone();
            }

            // Draw cursor during placement phase
            if (gameState.placementPhase) {
                drawCursor();
            }

            // Draw pieces
            if (gameState.placementPhase) {
                // Only draw player's placed pieces during placement
                if (gameState.playingAs === 'White') {
                    gameState.whitePieces.filter(p => p.alive).forEach(p => drawPiece(p));
                } else {
                    gameState.blackPieces.filter(p => p.alive).forEach(p => drawPiece(p));
                }
            } else if (gameState.sideChosen) {
                // Draw all pieces after placement is done
                gameState.whitePieces.filter(p => p.alive).forEach(p => drawPiece(p));
                gameState.blackPieces.filter(p => p.alive).forEach(p => drawPiece(p));
            }
            // If side not chosen, draw empty board (no pieces)

            // Draw plan lines
            if (gameState.currentPlan) {
                drawPlan(gameState.currentPlan, '#ff4444', '#ff0000', squareSize * 0.3);
            }
            if (gameState.currentCounter) {
                drawPlan(gameState.currentCounter, '#44ff44', '#00ff00', squareSize * 0.4);
            }
        }

        function drawPlacementZone() {
            const bounds = getPlayerBounds();

            ctx.strokeStyle = PLACEMENT_ZONE_COLOR;
            ctx.lineWidth = 2;

            const x = 0;
            const y = bounds.minY * squareSize;
            const width = BOARD_WIDTH * squareSize;
            const height = (bounds.maxY - bounds.minY + 1) * squareSize;

            ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);
        }

        function drawCursor() {
            const x = gameState.cursorX * squareSize;
            const y = gameState.cursorY * squareSize;

            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 4;
            ctx.strokeRect(x + 2, y + 2, squareSize - 4, squareSize - 4);
        }

        function drawPiece(piece) {
            const cx = piece.x * squareSize + squareSize / 2;
            const cy = piece.y * squareSize + squareSize / 2;

            // Draw piece background circle
            ctx.beginPath();
            ctx.arc(cx, cy, squareSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = piece.color === 'white' ? WHITE_PIECE_COLOR : BLACK_PIECE_COLOR;
            ctx.fill();
            ctx.strokeStyle = piece.color === 'white' ? WHITE_PIECE_OUTLINE : BLACK_PIECE_OUTLINE;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw piece letter with crisp rendering
            const fontSize = Math.floor(squareSize * 0.45);
            ctx.font = `bold ${fontSize}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = piece.color === 'white' ? '#333' : '#fff';

            ctx.imageSmoothingEnabled = false;

            const textX = Math.round(cx);
            const textY = Math.round(cy);
            ctx.fillText(piece.getLetter(), textX, textY);
        }

        function drawPlan(plan, lineColor, circleColor, circleRadius) {
            if (!plan || !plan.path || plan.path.length < 2) return;

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            const startX = plan.path[0].x * squareSize + squareSize / 2;
            const startY = plan.path[0].y * squareSize + squareSize / 2;
            ctx.moveTo(startX, startY);

            for (let i = 1; i < plan.path.length; i++) {
                const px = plan.path[i].x * squareSize + squareSize / 2;
                const py = plan.path[i].y * squareSize + squareSize / 2;
                ctx.lineTo(px, py);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            const target = plan.path[plan.path.length - 1];
            const tx = target.x * squareSize + squareSize / 2;
            const ty = target.y * squareSize + squareSize / 2;

            ctx.beginPath();
            ctx.arc(tx, ty, circleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = circleColor;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // ============== MOVE GENERATION ==============
        function getValidMoves(piece, allPieces, isBlack = false) {
            const moves = [];
            const occupied = new Map();

            allPieces.forEach(p => {
                if (p.alive) {
                    occupied.set(`${p.x},${p.y}`, p);
                }
            });

            switch (piece.type) {
                case 'pawn':
                    moves.push(...getPawnMoves(piece, occupied, isBlack));
                    break;
                case 'rook':
                    moves.push(...getRookMoves(piece, occupied, isBlack));
                    break;
                case 'knight':
                    moves.push(...getKnightMoves(piece, occupied, isBlack));
                    break;
                case 'bishop':
                    moves.push(...getBishopMoves(piece, occupied, isBlack));
                    break;
                case 'queen':
                    moves.push(...getRookMoves(piece, occupied, isBlack));
                    moves.push(...getBishopMoves(piece, occupied, isBlack));
                    break;
                case 'king':
                    moves.push(...getKingMoves(piece, occupied, isBlack));
                    break;
            }

            return moves;
        }

        function getPawnMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const direction = piece.color === 'black' ? 1 : -1;
            const newY = piece.y + direction;

            if (newY >= 0 && newY < BOARD_HEIGHT) {
                if (!occupied.has(`${piece.x},${newY}`)) {
                    moves.push({ x: piece.x, y: newY, path: [{ x: piece.x, y: piece.y }, { x: piece.x, y: newY }] });
                }

                if (!noCapture) {
                    for (const dx of [-1, 1]) {
                        const newX = piece.x + dx;
                        if (newX >= 0 && newX < BOARD_WIDTH) {
                            const target = occupied.get(`${newX},${newY}`);
                            if (target && target.color !== piece.color) {
                                moves.push({ x: newX, y: newY, path: [{ x: piece.x, y: piece.y }, { x: newX, y: newY }], capture: target });
                            }
                        }
                    }
                }
            }

            return moves;
        }

        function getRookMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            for (const [dx, dy] of directions) {
                const path = [{ x: piece.x, y: piece.y }];
                let x = piece.x + dx;
                let y = piece.y + dy;

                while (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    path.push({ x, y });
                    const target = occupied.get(`${x},${y}`);

                    if (target) {
                        if (!noCapture && target.color !== piece.color) {
                            moves.push({ x, y, path: [...path], capture: target });
                        }
                        break;
                    }

                    moves.push({ x, y, path: [...path] });
                    x += dx;
                    y += dy;
                }
            }

            return moves;
        }

        function getBishopMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

            for (const [dx, dy] of directions) {
                const path = [{ x: piece.x, y: piece.y }];
                let x = piece.x + dx;
                let y = piece.y + dy;

                while (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    path.push({ x, y });
                    const target = occupied.get(`${x},${y}`);

                    if (target) {
                        if (!noCapture && target.color !== piece.color) {
                            moves.push({ x, y, path: [...path], capture: target });
                        }
                        break;
                    }

                    moves.push({ x, y, path: [...path] });
                    x += dx;
                    y += dy;
                }
            }

            return moves;
        }

        function getKnightMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const jumps = [
                [2, 1], [2, -1], [-2, 1], [-2, -1],
                [1, 2], [1, -2], [-1, 2], [-1, -2]
            ];

            for (const [dx, dy] of jumps) {
                const x = piece.x + dx;
                const y = piece.y + dy;

                if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    const target = occupied.get(`${x},${y}`);

                    if (noCapture) {
                        if (!target) {
                            const path = [{ x: piece.x, y: piece.y }];
                            if (Math.abs(dx) === 2) {
                                path.push({ x: piece.x + dx, y: piece.y });
                                path.push({ x, y });
                            } else {
                                path.push({ x: piece.x, y: piece.y + dy });
                                path.push({ x, y });
                            }
                            moves.push({ x, y, path });
                        }
                    } else {
                        if (!target || target.color !== piece.color) {
                            const path = [{ x: piece.x, y: piece.y }];
                            if (Math.abs(dx) === 2) {
                                path.push({ x: piece.x + dx, y: piece.y });
                                path.push({ x, y });
                            } else {
                                path.push({ x: piece.x, y: piece.y + dy });
                                path.push({ x, y });
                            }

                            const move = { x, y, path };
                            if (target && target.color !== piece.color) {
                                move.capture = target;
                            }
                            moves.push(move);
                        }
                    }
                }
            }

            return moves;
        }

        function getKingMoves(piece, occupied, noCapture = false) {
            const moves = [];
            const directions = [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            for (const [dx, dy] of directions) {
                const x = piece.x + dx;
                const y = piece.y + dy;

                if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                    const target = occupied.get(`${x},${y}`);

                    if (noCapture) {
                        if (!target) {
                            moves.push({ x, y, path: [{ x: piece.x, y: piece.y }, { x, y }] });
                        }
                    } else {
                        if (!target || target.color !== piece.color) {
                            const move = { x, y, path: [{ x: piece.x, y: piece.y }, { x, y }] };
                            if (target && target.color !== piece.color) {
                                move.capture = target;
                            }
                            moves.push(move);
                        }
                    }
                }
            }

            return moves;
        }

        // ============== AI HELPERS ==============
        function buildOccupiedMapAfterBlackMove(allPieces, movingPiece, fromX, fromY, toX, toY) {
            const occ = new Map();
            for (const p of allPieces) {
                if (!p.alive) continue;
                occ.set(`${p.x},${p.y}`, p);
            }
            occ.delete(`${fromX},${fromY}`);
            occ.set(`${toX},${toY}`, movingPiece);
            return occ;
        }

        function openFileToBottomScore(occ, x, y) {
            const bottomY = BOARD_HEIGHT - 1;
            if (y >= bottomY) return 0;
            if (occ.has(`${x},${bottomY}`)) return 0;
            for (let yy = y + 1; yy < bottomY; yy++) {
                if (occ.has(`${x},${yy}`)) return 0;
            }
            const dist = bottomY - y;
            return 22 + dist * 2;
        }

        function openDiagonalToBottomScore(occ, x, y) {
            const bottomY = BOARD_HEIGHT - 1;
            if (y >= bottomY) return 0;

            let best = 0;
            const dirs = [[1, 1], [-1, 1]];
            for (const [dx, dy] of dirs) {
                let cx = x + dx;
                let cy = y + dy;
                while (cx >= 0 && cx < BOARD_WIDTH && cy >= 0 && cy < BOARD_HEIGHT) {
                    if (occ.has(`${cx},${cy}`)) break;
                    if (cy === bottomY) {
                        const dist = bottomY - y;
                        best = Math.max(best, 22 + dist * 2);
                        break;
                    }
                    cx += dx;
                    cy += dy;
                }
            }
            return best;
        }

        function wouldRepeatSecondToLast(candidate) {
            const h = gameState.blackMoveHistory;
            if (h.length < 2) return false;
            const secondLast = h[h.length - 2];
            return (
                secondLast.piece === candidate.piece &&
                secondLast.fromX === candidate.fromX &&
                secondLast.fromY === candidate.fromY &&
                secondLast.toX === candidate.toX &&
                secondLast.toY === candidate.toY
            );
        }

        // ============== AI ==============
        function blackAI() {
            const allPieces = [...gameState.whitePieces, ...gameState.blackPieces];
            const alivePieces = gameState.blackPieces.filter(p => p.alive);
            if (alivePieces.length === 0) return null;

            const TYPE_ORDER = ['queen', 'rook', 'bishop', 'knight', 'king', 'pawn'];

            for (let pass = 0; pass < 2; pass++) {
                const enforceRepeatAvoid = (pass === 0);

                for (const type of TYPE_ORDER) {
                    const typePieces = alivePieces.filter(p => p.type === type);
                    if (typePieces.length === 0) continue;

                    let bestMove = null;
                    let bestScore = -Infinity;

                    for (const piece of typePieces) {
                        const moves = getValidMoves(piece, allPieces, true);

                        for (const move of moves) {
                            const fromX = piece.x, fromY = piece.y;
                            const toX = move.x, toY = move.y;

                            let score = toY;

                            if (toY === BOARD_HEIGHT - 1) {
                                score += 100 + piece.getValue() * 10;
                            }

                            score += piece.getValue() * 0.5;

                            const occAfter = buildOccupiedMapAfterBlackMove(allPieces, piece, fromX, fromY, toX, toY);
                            if (piece.type === 'rook') {
                                score += openFileToBottomScore(occAfter, toX, toY);
                            } else if (piece.type === 'bishop') {
                                score += openDiagonalToBottomScore(occAfter, toX, toY);
                            } else if (piece.type === 'queen') {
                                score += openFileToBottomScore(occAfter, toX, toY);
                                score += openDiagonalToBottomScore(occAfter, toX, toY);
                            }

                            score += Math.random() * 0.5;

                            const candidate = { piece, move, fromX, fromY, toX, toY };

                            if (enforceRepeatAvoid && wouldRepeatSecondToLast(candidate)) {
                                continue;
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { piece, move };
                            }
                        }
                    }

                    if (bestMove) return bestMove;
                }
            }

            return null;
        }

        function whiteAI(blackPlan) {
            if (!blackPlan) return null;

            const allPieces = [...gameState.whitePieces, ...gameState.blackPieces];
            const alivePieces = gameState.whitePieces.filter(p => p.alive);
            if (alivePieces.length === 0) return null;

            const targetX = blackPlan.move.x;
            const targetY = blackPlan.move.y;

            // 1) Intercept attempt
            let bestIntercept = null;
            let bestInterceptScore = -Infinity;

            for (const piece of alivePieces) {
                if (piece.type === 'pawn') {
                    const direction = -1;
                    const dx = targetX - piece.x;
                    const dy = targetY - piece.y;

                    if (Math.abs(dx) === 1 && dy === direction) {
                        const score = 1000 + blackPlan.piece.getValue() * 100 - piece.getValue();
                        if (score > bestInterceptScore) {
                            bestInterceptScore = score;
                            bestIntercept = {
                                kind: 'intercept',
                                piece,
                                move: {
                                    x: targetX,
                                    y: targetY,
                                    path: [{ x: piece.x, y: piece.y }, { x: targetX, y: targetY }]
                                }
                            };
                        }
                    }
                    continue;
                }

                const moves = getValidMoves(piece, allPieces, false);
                for (const move of moves) {
                    if (move.x === targetX && move.y === targetY) {
                        let score = 1000 + blackPlan.piece.getValue() * 100;
                        score -= piece.getValue();
                        if (score > bestInterceptScore) {
                            bestInterceptScore = score;
                            bestIntercept = { kind: 'intercept', piece, move };
                        }
                    }
                }
            }

            if (bestIntercept) return bestIntercept;

            // 2) Proactive capture elsewhere
            let bestCapture = null;
            let bestCaptureScore = -Infinity;

            for (const piece of alivePieces) {
                const moves = getValidMoves(piece, allPieces, false);

                for (const move of moves) {
                    if (!move.capture) continue;

                    if (move.x === targetX && move.y === targetY) continue;

                    const captured = move.capture;
                    if (!captured.alive || captured.color !== 'black') continue;

                    if (captured === blackPlan.piece) continue;

                    let score = captured.getValue() * 120 + captured.y * 1.5 - piece.getValue() * 6;
                    score += Math.random() * 0.25;

                    if (score > bestCaptureScore) {
                        bestCaptureScore = score;
                        bestCapture = { kind: 'capture', piece, move };
                    }
                }
            }

            if (bestCapture) return bestCapture;

            // 3) Mobilize toward center
            const centers = [
                { x: 7, y: 7 }, { x: 8, y: 7 },
                { x: 7, y: 8 }, { x: 8, y: 8 }
            ];

            const distToCenter = (x, y) => {
                let best = Infinity;
                for (const c of centers) {
                    const d = Math.abs(x - c.x) + Math.abs(y - c.y);
                    if (d < best) best = d;
                }
                return best;
            };

            let bestMobilize = null;
            let bestMobilizeScore = -Infinity;

            for (const piece of alivePieces) {
                const moves = getValidMoves(piece, allPieces, false);
                const curDist = distToCenter(piece.x, piece.y);

                for (const move of moves) {
                    if (move.capture) continue;
                    if (move.x === targetX && move.y === targetY) continue;

                    const newDist = distToCenter(move.x, move.y);
                    const improvement = curDist - newDist;

                    let score = improvement * 20 - newDist * 0.5;
                    if (piece.type !== 'pawn') score += 1.0;
                    score += Math.random() * 0.2;

                    if (score > bestMobilizeScore) {
                        bestMobilizeScore = score;
                        bestMobilize = { kind: 'mobilize', piece, move };
                    }
                }
            }

            if (bestMobilize) return bestMobilize;

            return null;
        }

        // ============== GAME LOOP ==============
        async function gameLoop() {
            while (gameState.running) {
                if (gameState.paused) {
                    await sleep(100);
                    continue;
                }

                const blackAlive = gameState.blackPieces.filter(p => p.alive).length;
                if (blackAlive === 0) {
                    setStatus('Game Complete');
                    gameState.running = false;
                    gameState.gameComplete = true;
                    updateControlButtons();
                    break;
                }

                const blackPlan = blackAI();
                if (!blackPlan) {
                    setStatus('Game Complete');
                    gameState.running = false;
                    gameState.gameComplete = true;
                    updateControlButtons();
                    break;
                }

                gameState.currentPlan = blackPlan.move;
                gameState.currentCounter = null;
                draw();
                setStatus(`Black ${blackPlan.piece.type} plans: (${blackPlan.piece.x},${blackPlan.piece.y}) â†’ (${blackPlan.move.x},${blackPlan.move.y})`);
                await sleep(gameState.delay);

                if (!gameState.running) break;

                const whitePlan = whiteAI(blackPlan);
                if (whitePlan) {
                    gameState.currentCounter = whitePlan.move;
                    draw();

                    if (whitePlan.kind === 'intercept') {
                        setStatus(`White ${whitePlan.piece.type} captures at (${whitePlan.move.x},${whitePlan.move.y})`);
                    } else if (whitePlan.kind === 'capture') {
                        setStatus(`White ${whitePlan.piece.type} captures black ${whitePlan.move.capture.type} at (${whitePlan.move.x},${whitePlan.move.y})`);
                    } else if (whitePlan.kind === 'mobilize') {
                        setStatus(`White mobilizes piece toward board center`);
                    }

                    await sleep(gameState.delay);
                }

                if (!gameState.running) break;

                let blackCaptured = false;

                if (whitePlan) {
                    if (whitePlan.kind === 'intercept') {
                        blackPlan.piece.alive = false;
                        blackCaptured = true;

                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    } else if (whitePlan.kind === 'capture') {
                        if (whitePlan.move.capture && whitePlan.move.capture.alive) {
                            whitePlan.move.capture.alive = false;
                            if (whitePlan.move.capture === blackPlan.piece) {
                                blackCaptured = true;
                            }
                        }

                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    } else if (whitePlan.kind === 'mobilize') {
                        whitePlan.piece.x = whitePlan.move.x;
                        whitePlan.piece.y = whitePlan.move.y;
                    }
                }

                if (!blackCaptured) {
                    const executed = {
                        piece: blackPlan.piece,
                        fromX: blackPlan.piece.x,
                        fromY: blackPlan.piece.y,
                        toX: blackPlan.move.x,
                        toY: blackPlan.move.y
                    };
                    gameState.blackMoveHistory.push(executed);
                    if (gameState.blackMoveHistory.length > 12) gameState.blackMoveHistory.shift();

                    blackPlan.piece.x = blackPlan.move.x;
                    blackPlan.piece.y = blackPlan.move.y;

                    if (blackPlan.piece.y === BOARD_HEIGHT - 1) {
                        gameState.blackReached += 1;
                        blackPlan.piece.alive = false;
                        flashBlackReachedBox();
                        setStatus(`Black ${blackPlan.piece.type} reached bottom row`);
                    }
                }

                gameState.currentPlan = null;
                gameState.currentCounter = null;
                draw();
                updateUI();

                await sleep(Math.max(1, gameState.delay / 2));
            }

            gameState.currentPlan = null;
            gameState.currentCounter = null;
            draw();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, Math.max(1, ms)));
        }

        // ============== UI ==============
        function updateUI() {
            const countEl = document.getElementById('blackReachedCount');
            const textEl = document.getElementById('blackReachedText');
            if (countEl) countEl.textContent = gameState.blackReached;
            if (textEl) {
                const pieceWord = gameState.blackReached === 1 ? 'Piece' : 'Pieces';
                textEl.textContent = `Black ${pieceWord} Reached the Bottom Row`;
            }
        }

        function fitStatusText() {
            const box = document.querySelector('.status');
            const el = document.getElementById('statusText');
            if (!box || !el) return;

            let size = 14;
            const minSize = 10;

            el.style.fontSize = size + 'px';

            let guard = 0;
            while (el.scrollHeight > box.clientHeight && size > minSize && guard < 60) {
                size -= 0.5;
                el.style.fontSize = size + 'px';
                guard++;
            }
        }

        function setStatus(text) {
            const el = document.getElementById('statusText');
            if (!el) return;
            el.textContent = text;
            fitStatusText();
        }

        function flashBlackReachedBox() {
            const box = document.getElementById('blackReachedBox');
            if (!box) return;

            box.classList.add('score-flash');

            if (flashTimeout) clearTimeout(flashTimeout);
            flashTimeout = setTimeout(() => {
                box.classList.remove('score-flash');
                flashTimeout = null;
            }, 260);
        }

        function updateControlButtons() {
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            if (!startBtn || !pauseBtn) return;

            // Disable both buttons if game is complete
            if (gameState.gameComplete) {
                startBtn.disabled = true;
                pauseBtn.disabled = true;
                startBtn.classList.remove('btn-state-on');
                pauseBtn.classList.remove('btn-state-on');
                return;
            }

            // Disable pause during placement phase
            if (gameState.placementPhase) {
                pauseBtn.disabled = true;
            } else if (gameState.running) {
                pauseBtn.disabled = false;
            }

            startBtn.classList.toggle('btn-state-on', !!gameState.running);
            pauseBtn.classList.toggle('btn-state-on', !!(gameState.running && gameState.paused));
        }

        function startGame() {
            // Don't start if game is complete
            if (gameState.gameComplete) return;

            // Don't start if in placement phase with pieces remaining
            if (gameState.placementPhase) {
                const totalRemaining = Object.values(gameState.piecesToPlace).reduce((a, b) => a + b, 0);
                if (totalRemaining > 0) return;
            }

            if (!gameState.running) {
                // End placement phase
                gameState.placementPhase = false;

                // Hide piece counts panel
                document.getElementById('pieceCountsPanel').classList.add('hidden');

                // Spawn opponent pieces now
                spawnOpponentPieces();

                gameState.running = true;
                gameState.paused = false;
                setStatus('Simulation running...');
                updateControlButtons();
                draw();
                gameLoop();
                return;
            }

            if (gameState.running && gameState.paused) {
                gameState.paused = false;
                setStatus('Resumed');
                updateControlButtons();
            }
        }

        function togglePause() {
            if (!gameState.running || gameState.gameComplete) {
                return;
            }
            gameState.paused = !gameState.paused;
            setStatus(gameState.paused ? 'Paused' : 'Resumed');
            updateControlButtons();
        }

        function showRoleDialog() {
            const overlay = document.getElementById('roleModalOverlay');
            if (overlay) overlay.classList.remove('hidden');
        }

        function hideRoleDialog() {
            const overlay = document.getElementById('roleModalOverlay');
            if (overlay) overlay.classList.add('hidden');
        }

        function chooseSide(color) {
            gameState.playingAs = color;
            gameState.sideChosen = true;
            const el = document.getElementById('playingAs');
            if (el) el.textContent = `Playing as ${color}`;
            hideRoleDialog();

            // Start placement phase
            startPlacementPhase();
        }

        function startPlacementPhase() {
            gameState.placementPhase = true;
            gameState.whitePieces = [];
            gameState.blackPieces = [];

            // Initialize pieces to place for player
            initializePiecesToPlace();

            // Set cursor to center of player's area
            if (gameState.playingAs === 'Black') {
                gameState.cursorX = 7;
                gameState.cursorY = 2; // Middle of rows 0-5
            } else {
                gameState.cursorX = 7;
                gameState.cursorY = 14; // Middle of rows 13-15
            }

            // Show piece counts panel
            document.getElementById('pieceCountsPanel').classList.remove('hidden');
            updatePieceCountsUI();

            // Disable start button until all pieces placed
            document.getElementById('startBtn').disabled = true;

            // Disable pause button during placement
            document.getElementById('pauseBtn').disabled = true;

            setStatus('Place your pieces using WASD to move, P/N/B/R/Q/K to place, X to remove.');
            updateControlButtons();
            draw();
        }

        function resetGame() {
            gameState.running = false;
            gameState.paused = false;
            gameState.gameComplete = false;
            gameState.blackReached = 0;
            gameState.currentPlan = null;
            gameState.currentCounter = null;
            gameState.blackMoveHistory = [];
            gameState.placementPhase = false;
            gameState.sideChosen = false;
            gameState.playingAs = null;
            gameState.whitePieces = [];
            gameState.blackPieces = [];
            gameState.piecesToPlace = {
                king: 0,
                queen: 0,
                rook: 0,
                bishop: 0,
                knight: 0,
                pawn: 0
            };

            // Hide piece counts panel
            document.getElementById('pieceCountsPanel').classList.add('hidden');

            // Re-enable start button
            document.getElementById('startBtn').disabled = false;

            // Disable pause button initially
            document.getElementById('pauseBtn').disabled = true;

            updateUI();
            draw();
            setStatus('Choose a side to begin');

            showRoleDialog();
            const playingEl = document.getElementById('playingAs');
            if (playingEl) playingEl.textContent = 'Playing as (choose a side)';

            updateControlButtons();
        }

        window.onload = init;
    </script>
</body>
</html>